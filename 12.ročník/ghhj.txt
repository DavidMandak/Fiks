Nejprve si vyjádříme přesné zadání úlohy, na vstupu pro každé zadání najdeme počet stanovišť n, počet cest mezi stanovišti m, popis každé z těchto cest, tedy stanoviště u a v které spojuje a její délku w a nakonec q dotazů, kde každý zadává množinu důležitých stanovišť S. Naším úkolem je pro každý dotaz a jeho množinu S najít stanoviště, které je nejlépe dosažitelné z těchto důležitých stanovišť, jinak řečeno stanoviště, které má nejmenší součet nejkratších cest k důležitým stanovištím z množiny S.
Program si nejprve jednoduše zpracuje data do seznamu ve kterém má každé stanoviště přiděleno své sousedy, a délky cest vedoucím k nim. Následovně se podívá zda je počet cest o 1 menší než počet stanovišť, protože pokud ano, tak víme, že se grafem stanovišť je strom a tudíž následující dotazy budeme řešit rychlejším způsobem, než když strom grafem nebude.
A teď algoritmus na řešení stromového grafu. Jako kořen si vždy zvolíme stanoviště 0 a vytvoříme si seznam s pořadím stanovišť, ve kterém chceme strom procházet. Algoritmus vytvoří pre-order pořadí využitím klasického DFS, což zajišťuje, že každý rodič musí být v pořadí dříve než všichni jeho potomci. Při vytvoření tohoto pořadí si také pro každé stanoviště uložíme jaké stanoviště je ve stromu jeho rodičem. Po této přípravě již začneme řešit každý dotaz zvlášť.  Nejprve si pro každé stanoviště zjistíme, kolik důležitých stanovišť se nachází v jeho podstromu, což je množina všech jeho přímých potomků, a jeho dosažitelnost vzhledem k nim. Toho dosáhneme tím, že využijeme vytvořeného pořadí, akorát pozpátku, tudíž budeme strom procházet „zespodu“. Tímto způsobem se dostaneme až ke kořenu, pro něž je celý strom podstromem, což znamená, že jsme pro něj získali jeho opravdovou dosažitelnost.
